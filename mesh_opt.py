from dolfin import *
from mshr import *
import random
import time

def Generate_Mesh(L=10, H=10, N=10, D_max=0.5, D_min=0.1, res = 100, dd = 0.2, raup=0.0, ramk=0.0):
	# Create mesh
    
	## Parameters of an in-line tube bundle
	R_max = D_max/2.0   # max radius
	R_min = D_min/2.0   # min radius
	kx = H/2.0
	ky = L/kx
	a = []
	for i in range(0, int(ky)):
	    a.append(i*2)
	
	def segments(R):
	    C = 2*3.14*R
	    const_for_h_find = 5.5
	    hstep = const_for_h_find/res
	    seg = int(C/hstep)
	    if(seg<3): return 3
	    else: return seg 
	
	def kvadrant(x, y):
	    r = x/kx
	    if(y>=kx): return int(a[int(r)]+1)
	    else: return int(a[int(r)])
	
	def neighbor(kvad):
	    lst = []
	    if(kvad % 2 == 0 and kvad > 0 and kvad < int(ky*2-1)):
	        lst = [kvad-2, kvad-1, kvad, kvad+1, kvad+2, kvad+3]
	    if(kvad % 2 != 0 and kvad > 0 and kvad < int(ky*2-1)):
	        lst = [kvad-3, kvad-2, kvad-1, kvad, kvad+1, kvad+2]
	    if(kvad == 0):
	        lst = [kvad, kvad+1, kvad+2, kvad+3]
	    if(kvad == 1):
	        lst = [kvad-1, kvad, kvad+1, kvad+2]
	    if(kvad == int(ky*2-1)):
	        lst = [kvad-3, kvad-2, kvad-1, kvad]
	    if(kvad == int(ky*2-1)-1):
	        lst = [kvad-2, kvad-1, kvad, kvad+1]
	    return lst
	
	domain = Rectangle(Point(0.0, 0.0), Point(L, H))
	
	
	X = []
	Y = []
	radius = []
	
	for i in range(0,int(ky)*2):
	    X.append([])
	    Y.append([])
	    radius.append([])
	    
	
	x = random.uniform(ramk, L-ramk)
	y = random.uniform(raup, H-raup)
	R = random.uniform(R_min, R_max)
	x = round(x, 3)
	y = round(y, 3)
	R = round(R, 3)
	
	circ = Circle(Point(x, y), R, segments(R))
	domain = domain - circ
	
	
	kv = kvadrant(x,y)
	
	X[kv].append(x)
	Y[kv].append(y)
	radius[kv].append(R)
	
	i = 1
	while i<N:
	    x = random.uniform(ramk, L-ramk)
	    y = random.uniform(raup, H-raup)
	    R = random.uniform(R_min, R_max)
	    x = round(x, 3)
	    y = round(y, 3)
	    R = round(R, 3)
	    lst = []
	    kv = kvadrant(x,y)
	    lst = neighbor(kv)
	    k = 0
	    for w in range(0, len(lst)):
	        j = 0
	        while(j<len(X[lst[w]])):
	            if(sqrt((X[lst[w]][j]-x)**2 + (Y[lst[w]][j]-y)**2)<=(radius[lst[w]][j]+R+dd)):
	                k+=1
	                break
	            else:
	                j+=1
	    if(k==0):
	        X[kv].append(x)
	        Y[kv].append(y)
	        radius[kv].append(R)
	        circ = Circle(Point(x, y), R, segments(R))
	        domain = domain - circ
	        i+=1
	
	time_e = time.time()
	print( "Geometry generated by " + str(time_e-time_c) + " seconds." + "\n" + "Starting generate mesh...")
	#exit()
	mesh = generate_mesh(domain, float(res))
	info(mesh)
	return mesh


time_c = time.time()



L = 10.0            # lenght of domain
H = 1.0             # height of domain
N = 40             # number of circles
D_max = 0.1         # max diameter
D_min = 0.02        # min diameter
res = 300           # grid resolution
dd = 0.02           # distance between holes
raup = 0.0          #R_max + DOLFIN_EPS   #distance between horizontal boundaries
ramk = 0.1          #distance between vertical boundaries



time1 = time.time()
mesh = Generate_Mesh(L, H, N, D_max, D_min, res, dd, raup, ramk)
#mesh = Generate_Mesh()
time2 = time.time()
# Check generated mesh
plot(mesh, title = "Mesh")
print( "Mesh generated by " + str(time2-time1) + " seconds.")
File("mesh.xml") << mesh
File("mesh.pvd") << mesh
interactive()
